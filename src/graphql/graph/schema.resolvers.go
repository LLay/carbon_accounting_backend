package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.36

import (
	"context"
	"fmt"

	"github.com/influxdata/influxdb-client-go/v2/api"
	"github.com/michelaquino/golang_api_skeleton/src/graphql/graph/model"
)

// GetAllMeasurements is the resolver for the getAllMeasurements field.
func (r *myQueryResolver) GetAllMeasurements(ctx context.Context) ([]*model.EnergyMeasurement, error) {

	query := `
		from(bucket:"my_bucket")
		|> range(start: -7d) 
		|> filter(fn: (r) => r._measurement == "energy_data")
    `
	// cannot query an empty range",

	queryAPI := r.influxClient.QueryAPI("my_organization")
	result, err := queryAPI.Query(context.Background(), query)
	if err != nil {
		return nil, err
	}

	energyMeasurements, err := DecodeResultToEnergyMeasurement(result)
	if err != nil {
		fmt.Printf("Error decoding result: %v\n", err)
		return nil, err
	}

	return energyMeasurements, nil
}

func DecodeResultToEnergyMeasurement(result *api.QueryTableResult) ([]*model.EnergyMeasurement, error) {
	energyMeasurements := []*model.EnergyMeasurement{}

	for result.Next() {
		if result.TableChanged() {
			// Handle table changes if needed
		}
		result.Record().ValueByKey("fuel_type_code")
		result.Record().Values()

		fmt.Printf("Record: %v\n", result.Record())
		// Record: _field:value,
		// _measurement:energy_data,
		// _start:2023-08-27 23:02:42.492756054 +0000 UTC,
		// _stop:2023-09-03 23:02:42.492756054 +0000 UTC,
		// _time:2023-08-30 00:00:00 +0000 UTC,
		// _value:1160,
		// fuel_type_code:COL,
		// fuel_type_name:Coal,
		// respondent_code:AECI,
		// respondent_name:Associated Electric Cooperative, Inc.,
		// result:_result,
		// table:0,
		// value_units:megawatthours
		// Value: 1160

		value := result.Record().Values()
		energyMeasurement, err := mapToEnergyMeasurement(value)
		if err != nil {
			return nil, err
		}

		energyMeasurements = append(energyMeasurements, energyMeasurement)
	}

	return energyMeasurements, nil
}

func mapToEnergyMeasurement(data map[string]interface{}) (*model.EnergyMeasurement, error) {
	var energyMeasurement model.EnergyMeasurement

	for key, value := range data {
		switch key {
		case "respondent_code":
			if strVal, ok := value.(string); ok {
				energyMeasurement.RespondentCode = strVal
			} else {
				return nil, fmt.Errorf("unexpected type for respondent_code")
			}
		case "respondent_name":
			if strVal, ok := value.(string); ok {
				energyMeasurement.RespondentName = strVal
			} else {
				return nil, fmt.Errorf("unexpected type for respondent_name")
			}
		case "fuel_type_code":
			if strVal, ok := value.(string); ok {
				energyMeasurement.FuelTypeCode = strVal
			} else {
				return nil, fmt.Errorf("unexpected type for fuel_type_code")
			}
		case "fuel_type_name":
			if strVal, ok := value.(string); ok {
				energyMeasurement.FuelTypeName = strVal
			} else {
				return nil, fmt.Errorf("unexpected type for fuel_type_name")
			}
		case "value_units":
			if strVal, ok := value.(string); ok {
				energyMeasurement.ValueUnits = strVal
			} else {
				return nil, fmt.Errorf("unexpected type for value_units")
			}
		case "_value":
			// print type of value
			fmt.Printf("Type of value: %T\n", value)
			if intVal, ok := value.(int64); ok {
				energyMeasurement.Value = int(intVal)
			} else {
				return nil, fmt.Errorf("unexpected type for value")
			}
		default:
			// intentionally do nothing as there are fields we don't care about such as "_value"
			// return nil, fmt.Errorf("unknown field: %s", key)
		}
	}

	return &energyMeasurement, nil
}

// MyQuery returns MyQueryResolver implementation.
func (r *Resolver) MyQuery() MyQueryResolver { return &myQueryResolver{r} }

type myQueryResolver struct{ *Resolver }
